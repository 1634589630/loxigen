# Copyright 2013, Big Switch Networks, Inc.
#
# LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
# the following special exception:
#
# LOXI Exception
#
# As a special exception to the terms of the EPL, you may distribute libraries
# generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
# that copyright and licensing notices generated by LoxiGen are not altered or removed
# from the LoxiGen Libraries and the notice provided below is (i) included in
# the LoxiGen Libraries, if distributed in source code form and (ii) included in any
# documentation for the LoxiGen Libraries, if distributed in binary form.
#
# Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
#
# You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
# a copy of the EPL at:
#
# http://www.eclipse.org/legal/epl-v10.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# EPL for the specific language governing permissions and limitations
# under the EPL.

#
# Miscellaneous type information
#
# Define the map between sub-class types and wire values.  In each
# case, an array indexed by wire version gives a hash from identifier
# to wire value.
#

import c_gen.of_g_legacy as of_g
import sys
from generic_utils import *
import loxi_utils.loxi_utils as loxi_utils
import c_gen.loxi_utils_legacy as loxi_utils
import loxi_globals

invalid_type = "invalid_type"

################################################################
#
# Define type data for inheritance classes:
#   instructions, actions, queue properties and OXM
#
# Messages are not in this group; they're treated specially for now
#
# These are indexed by wire protocol number
#
################################################################

inheritance_roots = [
    'of_instruction',
    'of_instruction_id',
    'of_action',
    'of_action_id',
    'of_oxm',
    'of_queue_prop',
    'of_hello_elem',
    'of_table_feature_prop',
    'of_meter_band',
    'of_bsn_vport',
    'of_bsn_tlv',
]

def class_is_virtual(cls):
    """
    Returns True if cls is a virtual class
    """
    if cls.endswith("header"):
        return True
    if loxi_utils.class_is_list(cls):
        return True
    return loxi_globals.unified.class_by_name(cls).virtual

# map from root class name to (map from wire version to set of subclass names)
inheritance_data = {}

# map from parent class name to set of subclass names
inheritance_map = dict()

def generate_maps():
    def inheritance_root(ofclass):
        if not ofclass.superclass:
            if ofclass.name in inheritance_roots:
                return ofclass
            else:
                return None
        else:
            return inheritance_root(ofclass.superclass)

    for version, protocol in loxi_globals.ir.items():
        wire_version = version.wire_version
        for ofclass in protocol.classes:
            root = inheritance_root(ofclass)
            if not root or root == ofclass:
                continue

            assert ofclass.name.startswith(root.name + '_')
            subcls = ofclass.name[len(root.name)+1:]

            if root.name not in inheritance_data:
                inheritance_data[root.name] = {}
            if wire_version not in inheritance_data[root.name]:
                inheritance_data[root.name][wire_version] = set()
            inheritance_data[root.name][wire_version].add(subcls)

            if root.name not in inheritance_map:
                inheritance_map[root.name] = set()
            inheritance_map[root.name].add(subcls)

def sub_class_map(base_type, version):
    """
    Returns an iterable object giving the instance nameys and subclass types
    for the base_type, version values
    """
    rv = []
    if base_type not in inheritance_map:
        return rv

    for instance in inheritance_map[base_type]:
        subcls = loxi_utils.instance_to_class(instance, base_type)
        if not loxi_utils.class_in_version(subcls, version):
            continue
        rv.append((instance, subcls))

    return rv
