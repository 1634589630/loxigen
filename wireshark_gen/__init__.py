# Copyright 2013, Big Switch Networks, Inc.
#
# LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
# the following special exception:
#
# LOXI Exception
#
# As a special exception to the terms of the EPL, you may distribute libraries
# generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
# that copyright and licensing notices generated by LoxiGen are not altered or removed
# from the LoxiGen Libraries and the notice provided below is (i) included in
# the LoxiGen Libraries, if distributed in source code form and (ii) included in any
# documentation for the LoxiGen Libraries, if distributed in binary form.
#
# Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
#
# You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
# a copy of the EPL at:
#
# http://www.eclipse.org/legal/epl-v10.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# EPL for the specific language governing permissions and limitations
# under the EPL.

import os
from collections import namedtuple
import loxi_utils.loxi_utils as utils
import loxi_front_end
import of_g
from loxi_ir import *
import field_info

templates_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'templates')

DissectorField = namedtuple("DissectorField", ["fullname", "name", "type", "base"])

proto_names = { 1: 'of10', 2: 'of11', 3: 'of12', 4: 'of13' }
def make_field_name(wire_version, ofclass_name, member_name):
    return "%s.%s.%s" % (proto_names[wire_version],
                         ofclass_name[3:],
                         member_name)

def get_field_info(version, cls, name, oftype):
    """
    Decide on a Wireshark type and base for a given field.

    Returns (type, base)
    """
    if oftype.startswith("list"):
        return "bytes", "NONE"

    ofproto = of_g.ir[version]
    enum = ofproto.enum_by_name(oftype)

    if enum:
        field_type = "uint32"
    elif oftype in field_info.oftype_to_wireshark_type:
        field_type = field_info.oftype_to_wireshark_type[oftype]
    else:
        print "WARN missing oftype_to_wireshark_type for", oftype
        field_type = "bytes"

    if enum:
        if enum.is_bitmask:
            field_base = "HEX"
        else:
            field_base = "DEC"
    elif oftype in field_info.field_to_base:
        field_base = field_info.field_to_base[name]
    elif oftype in field_info.oftype_to_base:
        field_base = field_info.oftype_to_base[oftype]
    else:
        print "WARN missing oftype_to_base for", oftype
        field_base = "NONE"

    return field_type, field_base

def create_fields():
    r = []
    for wire_version, ofproto in of_g.ir.items():
        for ofclass in ofproto.classes:
            for m in ofclass.members:
                if isinstance(m, OFPadMember):
                    continue
                fullname = make_field_name(wire_version, ofclass.name, m.name)
                field_type, field_base = get_field_info(wire_version, ofclass.name, m.name, m.oftype)
                r.append(DissectorField(fullname, m.name, field_type, field_base))

    return r

enum_tables = {
    'of13.flow_mod.type': 'enum_v4_ofp_type',
    'of13.error_msg.type': 'enum_v4_ofp_type',
    'of13.stats_request.type': 'enum_v4_ofp_type',
    'of13.stats_request.stats_type': 'enum_v4_ofp_stats_type',
    'of13.stats_request.flags': 'enum_v4_ofp_stats_request_flags',
    'of13.stats_reply.type': 'enum_v4_ofp_type',
    'of13.stats_reply.stats_type': 'enum_v4_ofp_stats_type',
    'of13.stats_reply.flags': 'enum_v4_ofp_stats_reply_flags',
    'of13.flow_mod.table_id': 'enum_v4_ofp_table',
    'of13.flow_mod._command': 'enum_v4_ofp_flow_mod_command',
    'of13.flow_mod.out_port': 'enum_v4_ofp_port',
    'of13.flow_mod.out_group': 'enum_v4_ofp_group',
    'of13.error_msg.err_type': 'enum_v4_ofp_error_type',
    'of13.port_mod.type': 'enum_v4_ofp_type',
    'of13.hello.type': 'enum_v4_ofp_type',
    'of13.features_request.type': 'enum_v4_ofp_type',
    'of13.features_reply.type': 'enum_v4_ofp_type',
    'of13.barrier_request.type': 'enum_v4_ofp_type',
    'of13.barrier_reply.type': 'enum_v4_ofp_type',
    'of13.echo_request.type': 'enum_v4_ofp_type',
    'of13.echo_reply.type': 'enum_v4_ofp_type',
    'of13.match_t.type': 'enum_v4_ofp_match_type'
}

def generate(out, name):
    context = {
        'fields': create_fields(),
        'enum_tables': enum_tables,
    }
    utils.render_template(out, "openflow.lua", [templates_dir], context)
