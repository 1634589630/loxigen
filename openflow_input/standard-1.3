// Copyright 2013, Big Switch Networks, Inc.
//
// LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
// the following special exception:
//
// LOXI Exception
//
// As a special exception to the terms of the EPL, you may distribute libraries
// generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
// that copyright and licensing notices generated by LoxiGen are not altered or removed
// from the LoxiGen Libraries and the notice provided below is (i) included in
// the LoxiGen Libraries, if distributed in source code form and (ii) included in any
// documentation for the LoxiGen Libraries, if distributed in binary form.
//
// Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//
// You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
// a copy of the EPL at:
//
// http://www.eclipse.org/legal/epl-v10.html
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// EPL for the specific language governing permissions and limitations
// under the EPL.

#version 4

struct ofp_header {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
};

// Special structures used for managing scalar list elements
struct ofp_uint32 {
    uint32_t value;
};

// Special structures used for managing scalar list elements
struct ofp_uint8 {
    uint8_t value;
};

struct ofp_hello_elem {
    uint16_t type;
    uint16_t length;
};

struct ofp_hello_elem_versionbitmap {
    uint16_t type;
    uint16_t length;
    list(of_uint32_t) bitmaps;
};

struct ofp_hello {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    list(of_hello_elem_t) elements;
};

struct ofp_echo_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    of_octets_t data;
};

struct ofp_echo_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    of_octets_t data;
};

struct ofp_experimenter {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter;
    uint32_t subtype;
    of_octets_t data;
};

struct ofp_barrier_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
};

struct ofp_barrier_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
};

struct ofp_get_config_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
};

struct ofp_get_config_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t flags;
    uint16_t miss_send_len;
};

struct ofp_set_config {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t flags;
    uint16_t miss_send_len;
};

struct ofp_table_mod {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint8_t table_id;
    uint8_t[3] pad;
    uint32_t config;
};

struct ofp_port_desc {
    of_port_no_t port_no;
    uint8_t[4] pad;
    of_mac_addr_t hw_addr;
    uint8_t[2] pad2;
    of_port_name_t name;
    uint32_t config;
    uint32_t state;
    uint32_t curr;
    uint32_t advertised;
    uint32_t supported;
    uint32_t peer;
    uint32_t curr_speed;
    uint32_t max_speed;
};

struct ofp_features_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
};

struct ofp_features_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint64_t datapath_id;
    uint32_t n_buffers;
    uint8_t n_tables;
    uint8_t auxiliary_id;
    uint8_t[2] pad;
    uint32_t capabilities;
    uint32_t reserved;
};

struct ofp_port_status {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint8_t reason;
    uint8_t[7] pad;
    of_port_desc_t desc;
};

struct ofp_port_mod {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    of_port_no_t port_no;
    uint8_t[4] pad;
    of_mac_addr_t hw_addr;
    uint8_t[2] pad2;
    uint32_t config;
    uint32_t mask;
    uint32_t advertise;
    uint8_t[4] pad3;
};

// FIXME Does this need to be v4?
struct ofp_match_v3 {
    uint16_t type;
    uint16_t length;
    list(of_oxm_t) oxm_list;
};

struct ofp_oxm_experimenter_header {
    uint32_t oxm_header;
    uint32_t experimenter;
    of_octets_t data;
};

// This looks like an action header, but is standalone.  See 
// ofp_table_features_prop_actions
struct ofp_action_id {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_action_output {
    uint16_t type;
    uint16_t len;
    of_port_no_t port;
    uint16_t max_len;
    uint8_t[6] pad;
};

struct ofp_action_copy_ttl_out {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_action_copy_ttl_in {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_action_set_mpls_ttl {
    uint16_t type;
    uint16_t len;
    uint8_t mpls_ttl;
    uint8_t[3] pad;
};

struct ofp_action_dec_mpls_ttl {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_action_push_vlan {
    uint16_t type;
    uint16_t len;
    uint16_t ethertype;
    uint8_t[2] pad;
};

struct ofp_action_pop_vlan {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_action_push_mpls {
    uint16_t type;
    uint16_t len;
    uint16_t ethertype;
    uint8_t[2] pad;
};

struct ofp_action_pop_mpls {
    uint16_t type;
    uint16_t len;
    uint16_t ethertype;
    uint8_t[2] pad;
};

struct ofp_action_set_queue {
    uint16_t type;
    uint16_t len;
    uint32_t queue_id;
};

struct ofp_action_group {
    uint16_t type;
    uint16_t len;
    uint32_t group_id;
};

struct ofp_action_set_nw_ttl {
    uint16_t type;
    uint16_t len;
    uint8_t nw_ttl;
    uint8_t[3] pad;
};

struct ofp_action_dec_nw_ttl {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_action_set_field {
    uint16_t type;
    uint16_t len;
    of_octets_t field;
};

struct ofp_action_experimenter {
    uint16_t type;
    uint16_t len;
    uint32_t experimenter;
    of_octets_t data;
};

struct ofp_action_pop_pbb {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_action_push_pbb {
    uint16_t type;
    uint16_t len;
    uint16_t ethertype;
    uint8_t[2] pad;
};

struct ofp_action {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_instruction {
    uint16_t type;
    uint16_t len;
};

struct ofp_instruction_goto_table {
    uint16_t type;
    uint16_t len;
    uint8_t table_id;
    uint8_t[3] pad;
};

struct ofp_instruction_write_metadata {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
    uint64_t metadata;
    uint64_t metadata_mask;
};

struct ofp_instruction_write_actions {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
    list(of_action_t) actions;
};

struct ofp_instruction_apply_actions {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
    list(of_action_t) actions;
};

struct ofp_instruction_clear_actions {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_instruction_meter {
    uint16_t type;
    uint16_t len;
    uint32_t meter_id;
};

struct ofp_instruction_experimenter {
    uint16_t type;		
    uint16_t len;
    uint32_t experimenter;
    of_octets_t data;
};

struct ofp_flow_add {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_fm_cmd_t _command;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    of_port_no_t out_port;
    uint32_t out_group;
    uint16_t flags;
    uint8_t[2] pad;
    of_match_t match;
    list(of_instruction_t) instructions;
};

struct ofp_flow_modify {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_fm_cmd_t _command;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    of_port_no_t out_port;
    uint32_t out_group;
    uint16_t flags;
    uint8_t[2] pad;
    of_match_t match;
    list(of_instruction_t) instructions;
};

struct ofp_flow_modify_strict {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_fm_cmd_t _command;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    of_port_no_t out_port;
    uint32_t out_group;
    uint16_t flags;
    uint8_t[2] pad;
    of_match_t match;
    list(of_instruction_t) instructions;
};

struct ofp_flow_delete {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_fm_cmd_t _command;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    of_port_no_t out_port;
    uint32_t out_group;
    uint16_t flags;
    uint8_t[2] pad;
    of_match_t match;
    list(of_instruction_t) instructions;
};

struct ofp_flow_delete_strict {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_fm_cmd_t _command;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    of_port_no_t out_port;
    uint32_t out_group;
    uint16_t flags;
    uint8_t[2] pad;
    of_match_t match;
    list(of_instruction_t) instructions;
};

struct ofp_bucket {
    uint16_t len;
    uint16_t weight;
    of_port_no_t watch_port;
    uint32_t watch_group;
    uint8_t[4] pad;
    list(of_action_t) actions;
};

struct ofp_group_mod {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t command;
    uint8_t group_type;
    uint8_t pad;
    uint32_t group_id;
    list(of_bucket_t) buckets;
};

struct ofp_packet_out {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint32_t buffer_id;
    of_port_no_t in_port;
    uint16_t actions_len;
    uint8_t[6] pad;
    list(of_action_t) actions;
    of_octets_t data;
};

struct ofp_packet_in {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint32_t buffer_id;
    uint16_t total_len;
    uint8_t reason;
    uint8_t table_id;
    uint64_t cookie;
    of_match_t match;
    uint8_t[2] pad;
    of_octets_t data; /* FIXME: Ensure total_len gets updated */
};

struct ofp_flow_removed {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint16_t priority;
    uint8_t reason;
    uint8_t table_id;
    uint32_t duration_sec;
    uint32_t duration_nsec;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint64_t packet_count;
    uint64_t byte_count;
    of_match_t match;
};

struct ofp_meter_band {
    uint16_t        type;
    uint16_t        len;
//    uint32_t        rate;  // These are excluded b/c this is the header
//    uint32_t        burst_size;  // These are excluded b/c this is the header
};

struct ofp_meter_band_drop {
    uint16_t        type;
    uint16_t        len;
    uint32_t        rate;
    uint32_t        burst_size;
    uint8_t[4]      pad;
};

struct ofp_meter_band_dscp_remark {
    uint16_t        type;
    uint16_t        len;
    uint32_t        rate;
    uint32_t        burst_size;
    uint8_t         prec_level;
    uint8_t[3]      pad;
};

struct ofp_meter_band_experimenter {
    uint16_t        type;
    uint16_t        len;
    uint32_t        rate;
    uint32_t        burst_size;
    uint32_t        experimenter;
};

struct ofp_meter_mod {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t command;
    uint16_t flags;
    uint32_t meter_id;
    list(of_meter_band_t) meters;
};

struct ofp_error_msg {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t err_type;
    uint16_t code;
    of_octets_t data;
};

//struct ofp_error_experimenter_msg {
//    uint8_t version;
//    uint8_t type;
//    uint16_t length;
//    uint32_t xid;
//    uint16_t err_type;
//    uint16_t subtype;
//    uint32_t experimenter;
//    of_octets_t data;
//};

// STATS ENTRIES: flow, table, port, queue, group stats, group desc stats

struct ofp_flow_stats_entry {
    uint16_t length;
    uint8_t table_id;
    uint8_t pad;
    uint32_t duration_sec;
    uint32_t duration_nsec;
    uint16_t priority;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint8_t[6] pad2;
    uint64_t cookie;
    uint64_t packet_count;
    uint64_t byte_count;
    of_match_t match;
    list(of_instruction_t) instructions;
};


struct ofp_table_stats_entry {
    uint8_t table_id;
    uint8_t[3] pad;
    uint32_t active_count;
    uint64_t lookup_count;
    uint64_t matched_count;
};

struct ofp_port_stats_entry {
    of_port_no_t port_no;
    uint8_t[4] pad;
    uint64_t rx_packets;
    uint64_t tx_packets;
    uint64_t rx_bytes;
    uint64_t tx_bytes;
    uint64_t rx_dropped;
    uint64_t tx_dropped;
    uint64_t rx_errors;
    uint64_t tx_errors;
    uint64_t rx_frame_err;
    uint64_t rx_over_err;
    uint64_t rx_crc_err;
    uint64_t collisions;
    uint32_t duration_sec;
    uint32_t duration_nsec;
};

struct ofp_queue_stats_entry {
    of_port_no_t port_no;
    uint32_t queue_id;
    uint64_t tx_bytes;
    uint64_t tx_packets;
    uint64_t tx_errors;
    uint32_t duration_sec;
    uint32_t duration_nsec;
};

struct ofp_bucket_counter {
    uint64_t packet_count;
    uint64_t byte_count;
};

struct ofp_group_stats_entry {
    uint16_t length;
    uint8_t[2] pad;
    uint32_t group_id;
    uint32_t ref_count;
    uint8_t[4] pad;
    uint64_t packet_count;
    uint64_t byte_count;
    uint32_t duration_sec;
    uint32_t duration_nsec;
    list(of_bucket_counter_t) bucket_stats;
};

struct ofp_group_desc_stats_entry {
    uint16_t length;
    uint8_t type;
    uint8_t pad;
    uint32_t group_id;
    list(of_bucket_t) buckets;
};

// STATS: 
//  Desc, flow, agg, table, port, queue, group, group_desc, group_feat, experi

struct ofp_desc_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
};

struct ofp_desc_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    of_desc_str_t mfr_desc;
    of_desc_str_t hw_desc;
    of_desc_str_t sw_desc;
    of_serial_num_t serial_num;
    of_desc_str_t dp_desc;
};

struct ofp_flow_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    uint8_t table_id;
    uint8_t[3] pad;
    of_port_no_t out_port;
    uint32_t out_group;
    uint8_t[4] pad2;
    uint64_t cookie;
    uint64_t cookie_mask;
    of_match_t match;
};

struct ofp_flow_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_flow_stats_entry_t) entries;
};

struct ofp_aggregate_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    uint8_t table_id;
    uint8_t[3] pad;
    of_port_no_t out_port;
    uint32_t out_group;
    uint8_t[4] pad2;
    uint64_t cookie;
    uint64_t cookie_mask;
    of_match_t match;
};

struct ofp_aggregate_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    uint64_t packet_count;
    uint64_t byte_count;
    uint32_t flow_count;
    uint8_t[4] pad;
};

// FIXME: These are padded to 8 byte align beyond the length indicated

struct ofp_table_feature_prop {
    uint16_t         type;
    uint16_t         length;
};

struct ofp_table_feature_prop_instructions {
    uint16_t         type;
    uint16_t         length;
    // FIXME Check if instruction_t is right for ids here
    list(of_instruction_t)   instruction_ids;
};

struct ofp_table_feature_prop_instructions_miss {
    uint16_t         type;
    uint16_t         length;
    list(of_instruction_t)   instruction_ids;
};

struct ofp_table_feature_prop_next_tables {
    uint16_t         type;
    uint16_t         length;
    list(of_uint8_t) next_table_ids;
};

struct ofp_table_feature_prop_next_tables_miss {
    uint16_t         type;
    uint16_t         length;
    list(of_uint8_t) next_table_ids;
};

struct ofp_table_feature_prop_write_actions {
    uint16_t         type;
    uint16_t         length;
    list(of_action_id_t) action_ids;
};

struct ofp_table_feature_prop_write_actions_miss {
    uint16_t         type;
    uint16_t         length;
    list(of_action_id_t) action_ids;
};

struct ofp_table_feature_prop_apply_actions {
    uint16_t         type;
    uint16_t         length;
    list(of_action_id_t) action_ids;
};

struct ofp_table_feature_prop_apply_actions_miss {
    uint16_t         type;
    uint16_t         length;
    list(of_action_id_t) action_ids;
};

struct ofp_table_feature_prop_match {
    uint16_t         type;
    uint16_t         length;
    list(of_uint32_t) oxm_ids;
};

struct ofp_table_feature_prop_wildcards {
    uint16_t         type;
    uint16_t         length;
    list(of_uint32_t) oxm_ids;
};

struct ofp_table_feature_prop_write_setfield {
    uint16_t         type;
    uint16_t         length;
    list(of_uint32_t) oxm_ids;
};

struct ofp_table_feature_prop_write_setfield_miss {
    uint16_t         type;
    uint16_t         length;
    list(of_uint32_t) oxm_ids;
};

struct ofp_table_feature_prop_apply_setfield {
    uint16_t         type;
    uint16_t         length;
    list(of_uint32_t) oxm_ids;
};

struct ofp_table_feature_prop_apply_setfield_miss {
    uint16_t         type;
    uint16_t         length;
    list(of_uint32_t) oxm_ids;
};

struct ofp_table_feature_prop_experimenter {
    uint16_t         type;
    uint16_t         length;
    uint32_t         experimenter;
    uint32_t         subtype;
    of_octets_t      experimenter_data;
};

// Not yet supported
// struct ofp_table_feature_prop_experimenter_miss {
//     uint16_t         type;
//     uint16_t         length;
//     uint32_t         experimenter;
//     uint32_t         subtype;
//     of_octets_t      experimenter_data;
// };

struct ofp_table_features {
    uint16_t length;
    uint8_t table_id;
    uint8_t[5] pad;
    of_table_name_t name;
    uint64_t metadata_match;
    uint64_t metadata_write;
    uint32_t config;
    uint32_t max_entries;
    list(of_table_feature_prop_t) properties;
};

struct ofp_meter_features {
    uint32_t    max_meter;
    uint32_t    band_types;
    uint32_t    capabilities;
    uint8_t     max_bands;
    uint8_t     max_color;
    uint8_t[2]     pad;
};

struct ofp_port_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    of_port_no_t port_no;
    uint8_t[4] pad;
};

struct ofp_port_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_port_stats_entry_t) entries;
};

struct ofp_queue_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    of_port_no_t port_no;
    uint32_t queue_id;
};

struct ofp_queue_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_queue_stats_entry_t) entries;
};

struct ofp_group_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    uint32_t group_id;
    uint8_t[4] pad;
};

struct ofp_group_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_group_stats_entry_t) entries;
};

struct ofp_group_desc_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
};

struct ofp_group_desc_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_group_desc_stats_entry_t) entries;
};

struct ofp_group_features_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
};

struct ofp_group_features_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    uint32_t types;
    uint32_t capabilities;
    uint32_t max_groups_all;
    uint32_t max_groups_select;
    uint32_t max_groups_indirect;
    uint32_t max_groups_ff;
    uint32_t actions_all;
    uint32_t actions_select;
    uint32_t actions_indirect;
    uint32_t actions_ff;
};

struct ofp_meter_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    uint32_t meter_id;
    uint8_t[4] pad;
};

struct ofp_meter_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_meter_stats_t) entries;
};

struct ofp_meter_config_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    uint32_t meter_id;
    uint8_t[4] pad;
};

struct ofp_meter_config_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_meter_band_t) entries;
};

// FIXME stats added to get things working
struct ofp_meter_features_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
};

// FIXME stats added to get things working
struct ofp_meter_features_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    of_meter_features_t features;
};

// FIXME stats added to get things working
struct ofp_table_features_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_table_features_t) entries;
};

// FIXME stats added to get things working
struct ofp_table_features_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_table_features_t) entries;
};

// FIXME stats added to get things working
struct ofp_port_desc_stats_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
};

// FIXME stats added to get things working
struct ofp_port_desc_stats_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint16_t stats_type;
    uint16_t flags;
    uint8_t[4] pad;
    list(of_port_desc_t) entries;
};

struct ofp_meter_band_stats {
    uint64_t        packet_band_count;
    uint64_t        byte_band_count;
};

struct ofp_meter_stats {
    uint32_t        meter_id;
    uint16_t        len;
    uint8_t[6]         pad;
    uint32_t        flow_count;
    uint64_t        packet_in_count;
    uint64_t        byte_in_count;
    uint32_t   duration_sec;
    uint32_t   duration_nsec;
    list(of_meter_band_stats_t) band_stats;
};

struct ofp_meter_config {
    uint16_t        length;
    uint16_t        flags;
    uint32_t        meter_id;
    list(of_meter_band_t) entries;
};

struct ofp_experimenter_multipart_header {
    uint32_t experimenter;
    uint32_t subtype;
};

// END OF STATS OBJECTS

struct ofp_queue_prop {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
};

struct ofp_queue_prop_min_rate {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
    uint16_t rate;
    uint8_t[6] pad;
};

struct ofp_queue_prop_max_rate {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
    uint16_t rate;
    uint8_t[6] pad;
};

struct ofp_queue_prop_experimenter {
    uint16_t type;
    uint16_t len;
    uint8_t[4] pad;
    uint32_t experimenter;
    uint8_t[4] pad;
    of_octets_t data;
};

struct ofp_packet_queue {
    uint32_t queue_id;
    of_port_no_t port;
    uint16_t len;
    uint8_t[6] pad;
    list(of_queue_prop_t) properties;
};

struct ofp_queue_get_config_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    of_port_no_t port;
    uint8_t[4] pad;
};

struct ofp_queue_get_config_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    of_port_no_t port;
    uint8_t[4] pad;
    list(of_packet_queue_t) queues;
};

struct ofp_role_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint32_t role;
    uint8_t[4] pad;
    uint64_t generation_id;
};

struct ofp_role_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    of_octets_t data;
};

////////////////////////////////////////////////////////////////
// FIXME understand async; where do bitmasks live?
// Determine bitmap type for masks below.
// DOCUMENT masks where uint32_t[0] is interest for equal/master
//   while uint32_t[1] is interest for slave
////////////////////////////////////////////////////////////////

struct ofp_async_get_request {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint32_t packet_in_mask_equal_master;
    uint32_t packet_in_mask_slave;
    uint32_t port_status_mask_equal_master;
    uint32_t port_status_mask_slave;
    uint32_t flow_removed_mask_equal_master;
    uint32_t flow_removed_mask_slave;
};

struct ofp_async_get_reply {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint32_t packet_in_mask_equal_master;
    uint32_t packet_in_mask_slave;
    uint32_t port_status_mask_equal_master;
    uint32_t port_status_mask_slave;
    uint32_t flow_removed_mask_equal_master;
    uint32_t flow_removed_mask_slave;
};

struct ofp_async_set {
    uint8_t version;
    uint8_t type;
    uint16_t length;
    uint32_t xid;
    uint32_t packet_in_mask_equal_master;
    uint32_t packet_in_mask_slave;
    uint32_t port_status_mask_equal_master;
    uint32_t port_status_mask_slave;
    uint32_t flow_removed_mask_equal_master;
    uint32_t flow_removed_mask_slave;
};
